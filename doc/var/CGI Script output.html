<TITLE>CGI Script output</TITLE>
<H1><IMG ALT="" SRC="/images/CGIlogo.gif"> CGI Script Output</H1>
<HR>

<H2>Script output</H2>

The script sends its output to stdout. This output can either be a
document generated by the script, or instructions to the server for
retrieving the desired output. <P>
<HR>

<H2>Script naming conventions</H2>

Normally, scripts produce output which is interpreted and sent back to
the client. An advantage of this is that the scripts do not need to
send a full HTTP/1.0 header for every request.  <P>
<a name="nph">
Some scripts may want to avoid the extra overhead of the server
parsing their output, and talk directly to the client. In order to
distinguish these scripts from the other scripts, CGI requires that
the script name begins with nph- if a script does not want the server
to parse its header. In this case, it is the script's responsibility
to return a valid HTTP/1.0 (or HTTP/0.9) response to the client.  <P>

<HR>
<H2>Parsed headers</H2>

The output of scripts begins with a small header. This header consists
of text lines, in the same format as an <a
href="http://www.w3.org/hypertext/WWW/Protocols/HTTP/Object_Headers.html">
HTTP header</a>, terminated by a blank line (a line with only a
linefeed or CR/LF). <p>

Any headers which are not server directives are sent directly back to
the client. Currently, this specification defines three server
directives:<p>

<UL>
<LI> <CODE>Content-type</CODE> <P>

    This is the MIME type of the document you are returning.  <P>

<LI> <CODE>Location</CODE> <P>

    This is used to specify to the server that you are returning a
    reference to a document rather than an actual document. <P>

    If the argument to this is a URL, the server will issue a redirect
    to the client. <P>

    If the argument to this is a virtual path, the server will
    retrieve the document specified as if the client had requested
    that document originally. ? directives will work in here, but #
    directives must be redirected back to the client.<P>


<li> <a name="status"><code>Status</code></a><p>

    This is used to give the server an HTTP/1.0 <a
href="http://www.w3.org/hypertext/WWW/Protocols/HTTP/HTRESP.html">status
line</a> to send to the client. The format is <code>nnn xxxxx</code>,
where <code>nnn</code> is the 3-digit status code, and
<code>xxxxx</code> is the reason string, such as "Forbidden".<p>

</UL>

<HR>
<H2>Examples</H2>

Let's say I have a fromgratz to HTML converter. When my converter is
finished with its work, it will output the following on stdout (note
that the lines beginning and ending with --- are just for illustration
and would not be output): <P>

<PRE>
--- start of output ---
Content-type: text/html

--- end of output ---
</PRE>

Note the blank line after Content-type. <P>

Now, let's say I have a script which, in certain instances, wants to
return the document <CODE>/path/doc.txt</CODE> from this server just
as if the user had actually requested
<CODE>http://server:port/path/doc.txt</CODE> to begin with. In this
case, the script would output: <P>
<PRE>
--- start of output ---
Location: /path/doc.txt

--- end of output ---
</PRE>

The server would then perform the request and send it to the client.
<P>

Let's say that I have a script which wants to reference our gopher
server. In this case, if the script wanted to refer the user to
<CODE>gopher://gopher.ncsa.uiuc.edu/</CODE>, it would output: <P>

<PRE>
--- start of output ---
Location: gopher://gopher.ncsa.uiuc.edu/

--- end of output ---
</PRE>

Finally, I have a script which wants to talk to the client directly.
In this case, if the script is referenced with <A
HREF="env.html#protocol"><CODE>SERVER_PROTOCOL</CODE></A> of HTTP/1.0,
the script would output the following HTTP/1.0 response: <P>

<PRE>
--- start of output ---
HTTP/1.0 200 OK
Server: NCSA/1.0a6
Content-type: text/plain

This is a plaintext document generated on the fly just for you.

--- end of output ---
</PRE>


<HR>

<A HREF="interface.html"><IMG ALT="[Back]" SRC="/images/back.gif">Return to 